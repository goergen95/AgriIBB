randomPoints
which(index==2047)
which(index==2047)[seq(1,which(index==2047),2)]
which(index==2047)[seq(1,length(which(index==2047)),2)]
randomPoints[-which(index==2047)[seq(1,length(which(index==2047)),2)],]
randomPoints[-which(index==2047)[seq(1,length(which(index==2047)),2)],]
randomPoints = randomPoints[-which(index==2047)[seq(1,length(which(index==2047)),2)],]
buffer = gBuffer(randomPoints,byid = TRUE, width = 0.001475257*4.5)#width is 3 times pixel resolution)
notouch = gDisjoint(buffer, byid = TRUE)
index = apply(notouch,1,function(x){
return(sum(x))
})
index = as.vector(unlist(index))
unique(index)
gDisjoint()
?gDisjoint()
set.seed(123920)
randomPoints = lapply(provNames, function(x){
if(length(fields[which(fields$province==x),])==0) return(NULL)
tmp = spsample(fields[which(fields$province==x),],n=df$pixels[df$prov==x],"stratified")
return(tmp)
})
compact = function(x) Filter(Negate(is.null),x)
randomPoints = compact(randomPoints)
tmp = randomPoints[[1]]
for(i in 2:length(randomPoints)){
tmp = spRbind(tmp,randomPoints[[i]])
}
randomPoints = SpatialPointsDataFrame(tmp, data.frame(id=1:length(tmp)))
buffer = gBuffer(randomPoints,byid = TRUE, width = 0.001475257*4.5)#width is 3 times pixel resolution)
notouch = gDisjoint(buffer, byid = TRUE)
index = apply(notouch,1,function(x){
return(sum(x))
})
index = as.vector(unlist(index))
index = which(index==2047
index
index = which(index==2047)
index
notouch[index,]
which(!notouch)
which(notouch)
which(!notouch)
dim(which(!notouch))
index = apply(notouch,1,function(x){
return(which(x == FALSE))
})
index
index = as.vector(unlist(index))
index
randomPoints
index = apply(notouch,1,function(x){
if (sum(x)==0)return(0)
if (sum(x)>0)return(which(x)==FALSE)
})
index
notouch = gIntersect(buffer, byid = TRUE)
touch = gIntersects(buffer, byid = TRUE)
sum(touch[1,])
sum(touch[2,])
sum(touch[3,])
as.vector(touch[3,])
as.vector(touch[1,])
sum(touch[2,])
sum(touch[4,])
sum(touch[5,])
sum(touch[500,])
index = apply(touch,1,function(x){
if (sum(x)==1)return(0)
if (sum(x)>1)return(which(x)==TRUE)
})
index
index = as.vector(unlist(index))
index
which(index!=0)
index = apply(touch,1,function(x){
if (sum(x)==1)return(0)
if (sum(x)>1)return(which(x==TRUE))
})
index = as.vector(unlist(index))
which(index!=0)
index
?spsample
df$pixels = round(2500 * df$perc)
set.seed(123920)
randomPoints = lapply(provNames, function(x){
if(length(fields[which(fields$province==x),])==0) return(NULL)
tmp = spsample(fields[which(fields$province==x),],n=df$pixels[df$prov==x],"stratified")
return(tmp)
})
compact = function(x) Filter(Negate(is.null),x)
randomPoints = compact(randomPoints)
tmp = randomPoints[[1]]
for(i in 2:length(randomPoints)){
tmp = spRbind(tmp,randomPoints[[i]])
}
randomPoints = SpatialPointsDataFrame(tmp, data.frame(id=1:length(tmp)))
buffer = gBuffer(randomPoints,byid = TRUE, width = 0.001475257*4.5)#width is 3 times pixel resolution)
touch = gIntersects(buffer, byid = TRUE)
index = apply(touch,1,function(x){
if (sum(x)==1)return(0)
if (sum(x)>1)return(which(x==TRUE))
})
index = as.vector(unlist(index))
index
index = which(index!=0)
index
randomPoints = randomPoints[-index,]
randomPoints
writeOGR(tmp, dsn = "B:/ibb/results/shapes/random_points.shp",layer = "random_points",overwrite_layer = TRUE, driver ="ESRI Shapefile")
randomPoints = SpatialPointsDataFrame(randomPoints, data.frame(id=1:length(tmp)))
randomPoints = SpatialPointsDataFrame(randomPoints, data.frame(id=1:length(randomPoints)))
randomPoints
writeOGR(tmp, dsn = "B:/ibb/results/shapes/random_points.shp",layer = "random_points",overwrite_layer = TRUE, driver ="ESRI Shapefile")
writeOGR(tmp, dsn = "B:/ibb/results/shapes/random_points.shp",layer = "random_points",overwrite_layer = TRUE, driver ="ESRI Shapefile")
writeOGR(random, dsn = "B:/ibb/results/shapes/random_points.shp",layer = "random_points",overwrite_layer = TRUE, driver ="ESRI Shapefile")
writeOGR(randomPoints, dsn = "B:/ibb/results/shapes/random_points.shp",layer = "random_points",overwrite_layer = TRUE, driver ="ESRI Shapefile")
df
write.csv(df,"B:/ibb/results/randomSample.csv")
writeOGR(buffer, dsn = "B:/ibb/results/shapes/buffer.shp",layer = "buffer",overwrite_layer = TRUE, driver ="ESRI Shapefile")
install.packages("rater")
install.packages("raster")
library(raster)
first2016 = brick("B:/ibb/results/savG/savG_First2_2016.tif")
second2016 = brick("B:/ibb/results/savG/savG_Second2_2016.tif")
?merge
library(raster)
second2016 = brick("B:/ibb/results/savG/savG_Second2_2016.tif")
first2016 = brick("B:/ibb/results/savG/savG_First2_2016.tif")
?merge
t = merge(first2016,second2016)
t = mosaic(first2016,second2016)
second2016 = brick("B:/ibb/results/savG/savG_2003.tif")
library(raster)
second2016 = brick("B:/ibb/results/savG/savG_2003.tif")
second2016
plot(second2016[1],type = "l")
plot(as.numeric(second2016[1]),type = "l")
# read in needed files
points = readOGR("../results/shapes/random_points.shp")
# script to set up a random forest model based on forward-feature selection and cross-validation
library(rgdal)
library(carte)
library(doParallel)
library(CAST)
# specifiy number of cores for parallell processing
cores = 7
# read in needed files
points = readOGR("../results/shapes/random_points.shp")
setwd("B:/ibb/AgriIBB/.")
setwd("B:/ibb/AgriIBB/")
# read in needed files
points = readOGR("../results/shapes/random_points.shp")
summary(points$region)
x = summary(points$region)
x
as.vector(x)
install.packages("splitstackshape")
library(splitstackshape)
?stratified
head(points@data)
out = stratified(points@data,,c("region","active"),0.5)
out = stratified(points@data,c("region","active"),0.5)
out
str(out)
summary(out[,1:3])
summary(out[,1:4])
summary(out[,1:3])
summary(out[,3])
set.seed(834289348)
training = stratified(points@data,c("region","active"),0.5)
summary(out[,3])
length(which(training$active==0))
length(which(training$active==1))
testing = points@data[-training$id,]
testing$id %in% training$id
summary(training$region)
summary(testing$region)
length(whicht(training$active==1))
length(which(training$active==1))
length(which(testing$active==1))
length(which(training$active==0))
length(which(testing$active==0))
length(unique(training$region))
# using the CAST package to achieve space-dependend folds for the cross-validation
index = CAST::CreateSpacetimeFolds(training,spacevar = "region",k=length(unique(training$region)),seed=320543)#
tc = caret::trainControl(method="cv",number=length(unique(training$region)),classProbs = TRUE, index=index$index,indexOut=index$indexOut)
# ensure random forest is done as classification
training$active = make.names(training$active)
testing$active = make.names(testing$active)
# finally training the model, also with parallel processing to increase speed of computations
cl =  parallel::makeCluster(cores)
doParallel::registerDoParallel(cl)
rfModel = CAST::ffs(training[,predNames], training$active, method = "rf", withinSE = FALSE,importance = TRUE, trControl  = tc, metric = "Kappa")
stopCluster(cl)
predNames = readRDS("../results/prediction/predNames.rds")
cl =  parallel::makeCluster(cores)
doParallel::registerDoParallel(cl)
rfModel = CAST::ffs(training[,predNames], training$active, method = "rf", withinSE = FALSE,importance = TRUE, trControl  = tc, metric = "Kappa")
stopCluster(cl)
head(training)
head(testing)
head(as.data.frame(training))
# stratified random sample 50 percent of points for training and validation
# based on region and activity status
# set seed is used to ensure reproducibility
set.seed(834289348)
training = as.data.frame(stratified(points@data,c("region","active"),0.5))
testing = points@data[-training$id,]
# using the CAST package to achieve space-dependend folds for the cross-validation (leave-area-out)
index = CAST::CreateSpacetimeFolds(training,spacevar = "region",k=length(unique(training$region)),seed=320543)#
tc = caret::trainControl(method="cv",number=length(unique(training$region)),classProbs = TRUE, index=index$index,indexOut=index$indexOut)
# ensure random forest is done as classification
training$active = make.names(training$active)
testing$active = make.names(testing$active)
cl =  parallel::makeCluster(cores)
doParallel::registerDoParallel(cl)
rfModel = CAST::ffs(training[,predNames], training$active, method = "rf", withinSE = FALSE,importance = TRUE, trControl  = tc, metric = "Kappa")
stopCluster(cl)
warnings()
rfModel
pred = predict(rfModel,testing)
confMat = caret::confusionMatrix(pred,as.factor(testing$active))
confMat
saveRDS(rfModel,file="../results/prediction/rfModel.rds")
saveRDS(confMat,file="../results/prediction/confMat.rds")
rfModel$selectedvars_perf
rfModel$selectedvars
# script to predict agricultural activity for each year
library(raster)
# specifiy number of cores for parallell processing
cores = 7
# read in all needed files
rfModel = readRDS("../results/prediction/rfModel.rds")
predNames = readRDS("../results/prediction/predNames.rds")
agrMask = raster("../results/prediction/agrMask.tif")
NDVI = list.files("../results/savG/layered/",pattern=".tif",full.names =T)
GROW = list.files("../results/savG/",pattern=".tif",full.names = T)
NDVI
GROW
years = 2003:2016
# files are then saved to disk
beginCluster(cores)
for (year in years){
r = stack(NDVI[grep(year,NDVI)])
s =stack(GROW[grep(year,GROW)])
s = stack(r,s)
rm(r)
names(s) = predNames
print("Starting with raster prediction...")
predRas = clusterR(s,raster::predict, args=list(model = rfModel))
print("Starting to mask out non-agricultural pixels...")
predRas[is.na(agrMask)] = NA
print("Writing file to disk...")
writeRaster(predRas, filename=paste0("../results/prediction/activitiy_",year,".tif"),overwrite=TRUE)
print(paste0("Done with prediction for year ",year,"..."))
}
endCluster()
years = 2008:2016
beginCluster(cores)
for (year in years){
r = stack(NDVI[grep(year,NDVI)])
s =stack(GROW[grep(year,GROW)])
s = stack(r,s)
rm(r)
names(s) = predNames
print("Starting with raster prediction...")
predRas = clusterR(s,raster::predict, args=list(model = rfModel))
print("Starting to mask out non-agricultural pixels...")
predRas[is.na(agrMask)] = NA
print("Writing file to disk...")
writeRaster(predRas, filename=paste0("../results/prediction/activitiy_",year,".tif"),overwrite=TRUE)
print(paste0("Done with prediction for year ",year,"..."))
}
endCluster()
regions = readOGR("../results/shapes/regions.shp")
regions
regionNames = unique(regions@data$NAME_2)
fields = readOGR("../results/shapes/fields.shp")
predfiles = list.files("../results/prediction/", pattern = "activitiy", full.names = T)
years = 2003:2016
# create an index of the names of regions which do not have any agricultural areas
# this saves a lot of unecessary comuputation time when pixel values are extracted
content = gContains(regions,fields,byid=TRUE)
indexEmpty = as.vector(which(colSums(content)==0))
namesEmpty = regionNames[indexEmpty]
# initiate empty dataframes for acres of active and inactive areas for all regions and all years
dfActive = data.frame(regions=regionNames,
active_2003=rep(0,35),
active_2004=rep(0,35),
active_2005=rep(0,35),
active_2006=rep(0,35),
active_2007=rep(0,35),
active_2008=rep(0,35),
active_2009=rep(0,35),
active_2010=rep(0,35),
active_2011=rep(0,35),
active_2012=rep(0,35),
active_2013=rep(0,35),
active_2014=rep(0,35),
active_2015=rep(0,35),
active_2016=rep(0,35))
dfInactive = data.frame(regions=regionNames,
inactive_2003=rep(0,35),
inactive_2004=rep(0,35),
inactive_2005=rep(0,35),
inactive_2006=rep(0,35),
inactive_2007=rep(0,35),
inactive_2008=rep(0,35),
inactive_2009=rep(0,35),
inactive_2010=rep(0,35),
inactive_2011=rep(0,35),
inactive_2012=rep(0,35),
inactive_2013=rep(0,35),
inactive_2014=rep(0,35),
inactive_2015=rep(0,35),
inactive_2016=rep(0,35))
# applying a nested-for-loop which iterates through the years and regions
# pixel numbers for each regions are extracted, transformed to acrage
# and written into the corresponding cell of the dataframes created before
for (year in years){
r = raster(predfiles[grep(year,predfiles)])
for (region in regionNames){
if(region %in% namesEmpty) next
print(region)
tmp = extract(r, regions[which(regions$NAME_2==region),], df=TRUE)
tmp = na.omit(tmp)
active = sum(tmp[,2]==2) * 6.25
inactive = sum(tmp[,2]==1) * 6.25
dfActive[which(dfActive$regions==region),paste0("active_",year)] = active
dfInactive[which(dfInactive$regions==region),paste0("inactive_",year)] = inactive
}
print(paste0("Done with year ",year))
}
# create an index of the names of regions which do not have any agricultural areas
# this saves a lot of unecessary comuputation time when pixel values are extracted
content = gContains(regions,fields,byid=TRUE)
library(rgeos)
# create an index of the names of regions which do not have any agricultural areas
# this saves a lot of unecessary comuputation time when pixel values are extracted
content = gContains(regions,fields,byid=TRUE)
indexEmpty = as.vector(which(colSums(content)==0))
namesEmpty = regionNames[indexEmpty]
# initiate empty dataframes for acres of active and inactive areas for all regions and all years
dfActive = data.frame(regions=regionNames,
active_2003=rep(0,35),
active_2004=rep(0,35),
active_2005=rep(0,35),
active_2006=rep(0,35),
active_2007=rep(0,35),
active_2008=rep(0,35),
active_2009=rep(0,35),
active_2010=rep(0,35),
active_2011=rep(0,35),
active_2012=rep(0,35),
active_2013=rep(0,35),
active_2014=rep(0,35),
active_2015=rep(0,35),
active_2016=rep(0,35))
dfInactive = data.frame(regions=regionNames,
inactive_2003=rep(0,35),
inactive_2004=rep(0,35),
inactive_2005=rep(0,35),
inactive_2006=rep(0,35),
inactive_2007=rep(0,35),
inactive_2008=rep(0,35),
inactive_2009=rep(0,35),
inactive_2010=rep(0,35),
inactive_2011=rep(0,35),
inactive_2012=rep(0,35),
inactive_2013=rep(0,35),
inactive_2014=rep(0,35),
inactive_2015=rep(0,35),
inactive_2016=rep(0,35))
# applying a nested-for-loop which iterates through the years and regions
# pixel numbers for each regions are extracted, transformed to acrage
# and written into the corresponding cell of the dataframes created before
for (year in years){
r = raster(predfiles[grep(year,predfiles)])
for (region in regionNames){
if(region %in% namesEmpty) next
print(region)
tmp = extract(r, regions[which(regions$NAME_2==region),], df=TRUE)
tmp = na.omit(tmp)
active = sum(tmp[,2]==2) * 6.25
inactive = sum(tmp[,2]==1) * 6.25
dfActive[which(dfActive$regions==region),paste0("active_",year)] = active
dfInactive[which(dfInactive$regions==region),paste0("inactive_",year)] = inactive
}
print(paste0("Done with year ",year))
}
head(regions@data)
r = raster(predfiles[1])
r[] = NA
regionRas = rasterize(regions,r, regions$NAME_2)
plot(regionRas)
writeRaster(regionRas,filename="../results/prediction/regionRas.tif")
# initiate empty dataframes for acres of active and inactive areas for all regions and all years
dfActive = data.frame(regions=regionNames,
active_2003=rep(0,35),
active_2004=rep(0,35),
active_2005=rep(0,35),
active_2006=rep(0,35),
active_2007=rep(0,35),
active_2008=rep(0,35),
active_2009=rep(0,35),
active_2010=rep(0,35),
active_2011=rep(0,35),
active_2012=rep(0,35),
active_2013=rep(0,35),
active_2014=rep(0,35),
active_2015=rep(0,35),
active_2016=rep(0,35))
dfInactive = data.frame(regions=regionNames,
inactive_2003=rep(0,35),
inactive_2004=rep(0,35),
inactive_2005=rep(0,35),
inactive_2006=rep(0,35),
inactive_2007=rep(0,35),
inactive_2008=rep(0,35),
inactive_2009=rep(0,35),
inactive_2010=rep(0,35),
inactive_2011=rep(0,35),
inactive_2012=rep(0,35),
inactive_2013=rep(0,35),
inactive_2014=rep(0,35),
inactive_2015=rep(0,35),
inactive_2016=rep(0,35))
# applying a nested-for-loop which iterates through the years and regions
# pixel numbers for each regions are extracted, transformed to acrage
# and written into the corresponding cell of the dataframes created before
regVals = unique(values(regionRas))
regVals
# applying a nested-for-loop which iterates through the years and regions
# pixel numbers for each regions are extracted, transformed to acrage
# and written into the corresponding cell of the dataframes created before
regVals = na.omit(unique(values(regionRas)))
regVals
# applying a nested-for-loop which iterates through the years and regions
# pixel numbers for each regions are extracted, transformed to acrage
# and written into the corresponding cell of the dataframes created before
regVals = as.vector(na.omit(unique(values(regionRas))))
regVals
plot(regionRas[regionRas==1])
t = regionRas
t[t!=1] = NA
plot(t)
plot(regions[1,])
plot(regions[2,])
plot(regions[3,])
plot(regions[4,])
head(regions)
regions$ID = 1:length(regions)
regionRas = rasterize(regions,r, regions$ID)
writeRaster(regionRas,filename="../results/prediction/regionRas.tif")
writeRaster(regionRas,filename="../results/prediction/regionRas.tif", overwrite=T)
plot(regionRas)
# initiate empty dataframes for acres of active and inactive areas for all regions and all years
dfActive = data.frame(regions=regionNames,
active_2003=rep(0,35),
active_2004=rep(0,35),
active_2005=rep(0,35),
active_2006=rep(0,35),
active_2007=rep(0,35),
active_2008=rep(0,35),
active_2009=rep(0,35),
active_2010=rep(0,35),
active_2011=rep(0,35),
active_2012=rep(0,35),
active_2013=rep(0,35),
active_2014=rep(0,35),
active_2015=rep(0,35),
active_2016=rep(0,35))
dfInactive = data.frame(regions=regionNames,
inactive_2003=rep(0,35),
inactive_2004=rep(0,35),
inactive_2005=rep(0,35),
inactive_2006=rep(0,35),
inactive_2007=rep(0,35),
inactive_2008=rep(0,35),
inactive_2009=rep(0,35),
inactive_2010=rep(0,35),
inactive_2011=rep(0,35),
inactive_2012=rep(0,35),
inactive_2013=rep(0,35),
inactive_2014=rep(0,35),
inactive_2015=rep(0,35),
inactive_2016=rep(0,35))
# applying a nested-for-loop which iterates through the years and regions
# pixel numbers for each regions are extracted, transformed to acrage
# and written into the corresponding cell of the dataframes created before
regVals = as.vector(na.omit(unique(values(regionRas))))
regVals
regions$ID[regions$NAME_2==region]]
regions$ID[regions$NAME_2==region]
tmp = na.omit(values(regionRas[regionRas==regions$ID[regions$NAME_2==region]]))
values(regionRas[regionRas==regions$ID[regions$NAME_2==region]])
getValues(regionRas[regionRas==regions$ID[regions$NAME_2==region]])
regions$ID[regions$NAME_2==region]
regionRas[regionRas==11]
r[regionRas==regions$ID[regions$NAME_2==region]]
na.omit(r[regionRas==regions$ID[regions$NAME_2==region]])
tmp = na.omit(r[regionRas==regions$ID[regions$NAME_2==region]])
tmp
tmp = as.vector(na.omit(r[regionRas==regions$ID[regions$NAME_2==region]]))
tmp
tmp = na.omit(r[regionRas==regions$ID[regions$NAME_2==region]])
tmp
region
regionRas==regions$ID[regions$NAME_2==region]
regions$NAME_2==region
gions$ID[regions$NAME_2==region
